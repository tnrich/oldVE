<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">Ext.define(&quot;Teselagen.bio.sequence.common.Annotation&quot;, {
	constructor: function(data){

		var inputStart = data.start;
		var inputEnd = data.end;
		var initialLocation = Ext.create(&quot;Teselagen.bio.sequence.common.Location&quot;, {
			start: inputStart,
			end: inputEnd
		});

		var locations = [];
		locations.push(initialLocation);

		var BioException = Ext.create(&quot;Teselagen.bio.BioException&quot;, {
					message : &quot;Cannot set start when multiple Locations exist&quot;
				}); 
		
		this.getStart = function(){
			if ( locations.length &gt; 0 ) {
				return locations[0].getStart();
			} else {
				return -1;
			}
		}
		

		this.setStart = function(pStart){
			start = pStart;
		}


		this.setOneStart = function(pStart){
			if ( locations.length === 1 ) {
				locations[0].setStart(pStart);
			} else {	
				console.log(&quot;You've found an error!&quot;);		
				throw Ext.create(&quot;Teselagen.bio.BioException&quot;, {
					message : &quot;Cannot set start when multiple locations exist&quot;
				}); 
			}
		}

		this.getEnd = function(){
			if (locations.length &gt; 0){
				return locations[locations.length - 1].getEnd();
			}
			else {
				return 1;
			}
		}

		this.setEnd= function(pEnd){
			end = pEnd;
		}


		this.setOneEnd = function(pEnd){
			if  ( locations.length === 1 ) {
				locations[0].setEnd(pEnd);
			} else{
				console.log(&quot;You've found an error!&quot;);	
				throw Ext.create(&quot;Teselagen.bio.BioException&quot;, {
					message : &quot;Cannot set end when multiple Locations exist&quot;
				}); 
			}

		}

		this.getLocations = function(){
			return locations;
		}

		this.setLocations = function(pLocations){
			locations = pLocations;
		}

		this.contains = function(pAnnotation){
			var result = false; 

			//if (typeof pAnnotation ===) {};
			//First comparison tests whether this annotation is non-circular. 
			//Second comparison tests whether the input annotations is non-circular.
			//Non-circular pieces of DNA will have their starts before their ends.
			if (start &lt;= end) {
				if (annotation.getStart() &lt;= annotation.getEnd()) {
					result = ((start &lt;= annotation.getStart()) &amp;&amp; (end &gt;= annotation.getEnd()));
				};
			} else {
				if (annotation.getStart() &lt; annotation.getEnd()) {
					result = ((annotation.end &lt;= end) || (annotation.start &gt;= start));
				} else{
					result = ((start &lt;= annotation.start) &amp;&amp; (end &gt;= annotation.end));
				}
			}
			

			return result;
		}
		 
		this.isMultiLocation = function(){
			if ( this.locations.length &gt;= 2 ) {
				return true;
			} else {
				return false;
			}
		}
		/*
		this.shift = function (shiftBy, maxLength, circular){
			if ( shiftBy &gt; (maxLength - 1)) {
				throw Ext.create(&quot;Teselagen.bio.BioException&quot;, {
					message : &quot;Cannot shift by greater than maximum length&quot;
				}); 
			}

			var offset = this.start;
			var tempLocations = getNormalizedLocations();

			for (var i = 0; i &lt; tempLocations.getLocations().length; ++i ){ 
				location.setStart( location.getStart() + shiftBy );
				location.setEnd( location.getEnd() + shiftBy );
			}

			tempLocations = deNormalizeLocation(tempLocations, offset, maxLength, circular);
			locations = tempLocations;
		}
			 


		this.insertAt = function (position, insertLength, maxLength, circular){
			var shifting = 0;
			var tempEnd;
			var offset = locations[0].start;

			var normalizedPosition = position - offset;
			var circularAdjustment = 0;

			if (end &lt; start &amp;&amp; position &lt; end) {
				normalizedPosition += maxLength;
				circularAdjustment = -insertLength;
			}

			var tempLocations = getNormalizedLocations(maxLength);

			for (var i = 0; i &lt; tempLocations.length; i++ {
				currentLocation = tempLocations[i];
				if ( shifting == 0 ) {
					if (normalizedPosition &gt; currentLocation.start &amp;&amp; normalizedPosition &lt; currentLocation.end ) {
						currentLocation.end += insertLength;
						shifting = insertLength;
						continue;
					} else if ( normalizedPosition &lt; currentLocation.start ){
						currentLocation.start += insertLength;
						currentLocation.end += insertLength;
						shifting = insertLength;
					}
				} else {
					currentLocation.start += insertLength;
					currentLocation.end += insertLength;
				}
			}

			this.locations = deNormalizeLocation(tempLocations, offset, maxLength + insertLength, circular, circularAdjustment);

			return this;
		}


		this.deleteAt = function(cutStart, cutLength, maxLength, circular){
			if (cutLength &lt; 1) {
				exit;
			}

			var expectedNewLength = -1;

			var shifting = 0;
			var offset = locations[0].start;
			var normalizedCutStart = cutStart - offset;
			var circularAdjustment = 0;

			if (end &lt; start &amp;&amp; cutStart &gt;= 0  &amp;&amp; cutStart &lt; end) {
				normalizedCutStart += maxLength;
				circularAdjustment = cutLength;
			}

			var newMinimum = 0;
			var normalizedCutEnd = normalizedCutStart + cutLength;
			var tempLocations = getNormalizedLocations(maxLength);

			var normalizedStart = tempLocations[0].start;
			var normalizedEnd  = tempLocations[tempLocations.length - 1].end;

			if (normalizedCutStart &lt; normalizedStart &amp;&amp; normalizedCutEnd &lt;= normalizedStart) {
				expectedNewLength = normalizedEnd - normalizedStart;
			} else if (normalizedCutStart &lt; normalizedStart &amp;&amp; normalizedCutEnd &lt;= normalizedEnd) {
				expectedNewLength = normalizedEnd - (normalizedCutEnd);
			} else if (normalizedCutStart &gt;= normalizedStart &amp;&amp; normalizedCutEnd &lt;= normalizedEnd) {
				expectedNewLength = normalizedEnd -normalizedStart - cutLength;
			} else if (normalizedCutStart &lt;= normalizedEnd &amp;&amp; normalizedCutEnd &gt;= normalizedEnd) {
				expectedNewLength = normalizedCutStart - normalizedStart;
			}

			if (normalizedCutStart &lt; tempLocations[0].start) {
				if (normalizedCutStart + cutLength &gt;= tempLocations[0].start) {
					newMinimum = normalizedCutStart;
				} else if (normalizedCutStart + cutLength &lt;= tempLocations[0].start) {
					newMinimum = tempLocations[0].start - cutLength;
				}
			} else {
				newMinimum = tempLocations[0].start;
			}


			// if deletion happened before feature, shift only, no delete
			if (normalizedCutEnd &lt;= tempLocations[0].start) {
				for (var j:int = 0; j &lt; tempLocations.length; j++) {
					tempLocations[j].start -= cutLength;
					tempLocations[j].end -= cutLength;
				}
			} else {
				// do deletions
				var currentLocation;
	
				shifting = 0;
				
				for (var i = 0; i &lt; tempLocations.length; i++) {
					currentLocation = tempLocations[i];
					if (shifting == 0) {
						if (normalizedCutStart &gt;= currentLocation.end) {
							continue;
						} else if (normalizedCutEnd &lt;= currentLocation.start &amp;&amp; normalizedCutStart &lt;= currentLocation.start &amp;&amp; cutLength &gt; 0) { 
							// cuts are left, but is all before this location. Switch to shifting
							currentLocation.start -= cutLength;
							currentLocation.end -= cutLength;
							shifting = cutLength;
						} else if (normalizedCutEnd &lt;= currentLocation.end) {
							if (normalizedCutStart &lt; currentLocation.start) {
								// cut starts before and ends within this location
								currentLocation.start = normalizedCutStart;
								currentLocation.end -= cutLength;
								shifting = cutLength;
							} else if (normalizedCutStart &gt;= currentLocation.start) { 
								// cut entirely within this location
								currentLocation.end -= cutLength;
								shifting = cutLength;
							}
						} else if (normalizedCutEnd &gt; currentLocation.end) { 
							if (normalizedCutStart &lt; currentLocation.start) { 
								// cut starts before this location, and ends after this location
								currentLocation.start = normalizedCutStart;
								currentLocation.end = normalizedCutStart;
							} else if (normalizedCutStart &gt;= currentLocation.start) { 
								// cut starts within this location and continues after this location
								currentLocation.end = normalizedCutStart;
							}
						}
					} else { // shifting
						currentLocation.start -= shifting;
						currentLocation.end -= shifting;
					}
				} // end for (var i:int = 0; i &lt; tempLocations.length; i++) {
			}

			// remove zero length locations and combine locations that are next to each other
			var combinedLocations = [];
			for (i = 0; i &lt; tempLocations.length; i++) {
				if (combinedLocations.length == 0) {
					if (tempLocations[i].length &gt; 0) {
						combinedLocations.push(tempLocations[i]);	
					}
					continue;
				}
				if (combinedLocations[combinedLocations.length - 1].end == tempLocations[i].start) {
					combinedLocations[combinedLocations.length - 1].end = tempLocations[i].end;
				} else if (tempLocations[i].length &gt; 0) {
					combinedLocations.push(tempLocations[i]);
				}
			}
			
			// first and last location must fill the length of the feature.
			if (combinedLocations[0].start &gt; newMinimum) {
				combinedLocations[0].start = newMinimum;
			}
			
			if (combinedLocations[combinedLocations.length - 1].end != newMinimum + expectedNewLength) {
				combinedLocations[combinedLocations.length - 1].end = newMinimum + expectedNewLength;
			}
			
			locations = deNormalizeLocations(combinedLocations, offset, maxLength - cutLength, circular, circularAdjustment);

			return this;

		}

		this.reverseLocations = function (newStartIndex, newMaxLength, circular){
			var tempLocations = getNormalizedLocations(newMaxLength);
			tempLocations = reverseNormalizedLocations(tempLocations);
			tempLocations = deNormalizeLocations(tempLocations, newStartIndex, newMaxLength, circular);
			
			locations = tempLocations;

			return this;
		}

		var getNormalizedLocations = function(maxLength){
			if (locations.length == 0) {
				return null;
			}
			
			var result = [];
			var offset = locations[0].start;
			var newStart = 0;
			var newEnd = 0;
			var location;
			
			for (var i= 0; i &lt; locations.length; i++) {
				location = locations[i];	
				newStart = location.start - offset;
				if (newStart &lt; 0) {
					newStart += maxLength;
				}
				newEnd = location.end - offset;
				if (newEnd &lt; 0) {
					newEnd += maxLength;
				}
				result.push(Ext.create(&quot;Teselagen.bio.sequence.common.Location&quot;, {
					start: newStart,
					end: newEnd
				}));
			}
			return result;
		}

		var deNormalizeLocations = function(tempLocations, offset, maxLength, circularAdjustment){
			if (tempLocations.length === 0) {
				return null;
			}

			var result = [];
			var newStart;
			var newEnd;
			var location;

			for (var i = 0; i &lt; tempLocations.length; i++) {
				location = tempLocations[i];
				newStart = location.start + offset;
				if (circular &amp;&amp; newStart &gt; maxLength) {
					newStart -= maxLength + circularAdjustment;
				} else if (circular) {
					newStart -= circularAdjustment;
				}
				
				newEnd = location.end + offset;
				if (circular &amp;&amp; newEnd &gt; maxLength) {
					newEnd -= maxLength + circularAdjustment;
				} else if (circular) {
					newEnd -= circularAdjustment;
				}
				
				// On rare occasions, the calculated value is two circular distances away. Handle this case.
				if (circular &amp;&amp; location.start + offset == maxLength &amp;&amp; location.end + offset == maxLength + maxLength) {
					newStart = 0;
					newEnd = maxLength;
				}
				
				if (circular &amp;&amp; newStart &lt; 0) {
					newStart += maxLength;
				}
				
				if (circular &amp;&amp; newEnd &lt; 0) {
					newEnd += maxLength;
				}

				result.push(Ext.create(&quot;Teselagen.bio.sequence.common.Location&quot;, {
					start: newStart,
					end: newEnd	
				}));
			}
			return result;

		}

		function reverseNormalizedLocations(tempLocations){
			if (tempLocations.length === 0 ){
				return null;
			}

			var result = [];
			var offset = tempLocations[0].start;
			var location;
			var locationLength;
			var featureLength = tempLocations[tempLocations.length - 1].end - offset;
			var newStart;

			for (var i = tempLocations.length - 1; i &gt; -1; i--) {
				location = tempLocations[i];
				locationLength = location.end - location.start;
				newStart = featureLength - location.end;

				result.push(Ext.create(&quot;Teselagen.bio.sequence.common.Location&quot;, {
					start: newStart,
					end: newEnd	
				}));
			}
			
			return result;

		}

		function getOverlappingIndex (index){
			var result = -1;
			for (var index; index &lt; locations.length; index++) {
				var location:Location = locations[index];
				if (index &gt;= location.start &amp;&amp; index &lt;= location.end) {
					result = index;
					break;
				} 
			}
			
			return result;

		} */

		return this;
	},

});</pre>
</body>
</html>
